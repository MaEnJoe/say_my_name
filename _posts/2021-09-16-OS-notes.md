---
layout: post
title:  "Operating System Notes"
date:   2100-09-12 10:20:31 +0800
author : "leolijung"
categories: readingNotes
---

恐龍本

### CH7. Deadlock 

* Processes 在爭取有限的資源(硬體資源如光碟機、邏輯資源如檔案)
* 這個主題已經發展成熟很多年，沒甚麼更新了

#### Deadlock Characterization

四個deadlock 的條件，全部發生，會引發deadlock

1. Mutual exclusion
2. Hold and wait
3. Circular wait
4. No preemption

#### Resource allocation graph

可以用圖(Graph, linked list)偵測deadlock的發生

![](https://www.cs.jhu.edu/~yairamir/cs418/os4/img008.gif)

如果出現cycle，**有可能**出現deadlock。

#### Deadlock handling 

作業系統可以...

1. Design a protocol to **prevent** or **avoid** deadlocks

   (注意! **prevention** 和 **avoidance** 是兩個主題)

2. Allow the system to enter a deadlock state, **detect it and
   recover**.

   (偵測，並還原)

3. Ignore the problem and pretend that deadlocks never occur in
   the system. 

   (忽略，交給application 的 開發者去處理)

##### Deadlock prevention

1.  預防 Mutual exclusion: 

   **不可能**

2. 預防 Hold and wait

   protocol 1 :

   ​	一次拿全部需要的，做完通通釋放

   protocol 2 :

   ​	沒資源才能拿，拿了要立刻做事

3. 預防 Circular wait

   * 給資源(resource)分級

   * process索取資源只能越拿越高級(request in increasing order)

4. 預防 No preemption

   > 並不是所有種類資源都可以適用這個方法(its state must be easily saved and restore)，例如：列表機、光碟機

   protocol 1 :

   * 如果某process佔有一些資源，同時又索取一些無法立即拿到的資源，則手上握有的資源全部被搶占
   * 用清單紀錄下來被搶佔的資源，之後要還給該process

   protocol 2 :

   * process要的東西在別的process手上，如果別的process在等(wait)，就可以搶過來

##### Deadlock avoidancd

但是Deadlock prevention會導致資源使用效率低下。

只要有**額外的資訊**，deadlock是可以避免(avoidance)的，而不必使用prevention。

![](https://i.imgur.com/sKGoj7q.png)

**Avoidance algorithms** 保證系統保持safe state。做法是先假裝把資源分配給某個process，再使用下列演算法檢查是否處在**safe state**，不safe 的話就退回去：

​	for single instance of each resource type:

* **Resource-Allocation-Graph Algorithm**

![](https://i.imgur.com/S1CAHKM.png)

for multiple-instance :

* Banker's algorithm

##### deadlock detection

如果deadlock預防不了又不免不了，發生的時候至少要可以偵測到。

如果發現deadlock發生了，可以

1. Processtermination

2. Resource preempt

   要小心：

   * Selecting a victim
   * Rollback.
   * Starvation



